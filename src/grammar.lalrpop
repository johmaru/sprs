grammar;

use crate::ast::{Item, VarDecl, Expr, Stmt, Function, FunctionParam};
use crate::lexer::Token;

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        LBrace => Token::LBrace,
        RBrace => Token::RBrace,
        LParen => Token::LParen,
        RParen => Token::RParen,
        Plus   => Token::Plus,
        PlusPlus => Token::PlusPlus,
        Star   => Token::Star,
        Minus  => Token::Minus,
        MinusMinus => Token::MinusMinus,
        Div    => Token::Div,
        Eq     => Token::Eq,
        EqEq   => Token::EqEq,
        Neq    => Token::Neq,
        Semi   => Token::Semi,
        StrLiteral => Token::StrLiteral(String),
        If     => Token::If,
        Then   => Token::Then,
        Else   => Token::Else,
        IDENT  => Token::Ident(String),
        NUM    => Token::Num(i64),
        Comma  => Token::Comma,
        Function => Token::Function,
        Return => Token::Return,
    }
}

pub Start: Vec<Item> =
    <first:ItemNode> <rest:MoreItems> => {
        let mut v = vec![first];
        v.extend(rest);
        v
    };

MoreItems: Vec<Item> = {
    => vec![],
    <i:ItemNode> <mut rest:MoreItems> => {
        let mut v = vec![i];
        v.append(&mut rest);
        v
    }
};

ItemNode: Item = {
    FunctionDef,
    <v:VarDecl> => Item::VarItem(v),
};


FnKw: () = <tok:Function> => ();

FunctionDef: Item =
    FnKw <name:Ident> LParen <params:ParamList> RParen <body:Block> => {
        Item::FunctionItem(Function {
            ident: name,
            params,
            blk: body,
        })
    };

ParamList: Vec<FunctionParam> = {
    => vec![],
    <first:FunctionParamNode> <rest:MoreParams> => {
        let mut v = vec![first];
        v.extend(rest);
        v
    }
};

MoreParams: Vec<FunctionParam> = {
    => vec![],
    Comma <p:FunctionParamNode> <mut rest:MoreParams> => {
        let mut v = vec![p];
        v.append(&mut rest);
        v
    }
};

FunctionParamNode: FunctionParam =
    <id:Ident> => FunctionParam { ident: id };

ArgList: Vec<Expr> = {
    => vec![],
    <first:Expr> <rest:MoreArgs> => {
        let mut v = vec![first];
        v.extend(rest);
        v
    }
};

MoreArgs: Vec<Expr> = {
    => vec![],
    Comma <a:Expr> <mut rest:MoreArgs> => {
        let mut v = vec![a];
        v.append(&mut rest);
        v
    }
};

Block: Vec<Stmt> =
    LBrace <stmts:Stmts> RBrace => stmts;

Stmts: Vec<Stmt> = {
    => vec![],
    <s:Stmt> <mut rest:Stmts> => { rest.insert(0, s); rest }
};

Stmt: Stmt = {
    <v:VarDecl> => Stmt::Var(v),
    <e:Expr> Semi => Stmt::Expr(e),
    If <c:Expr> Then <then:Block> Else <else_blk:Block> =>
        Stmt::If {
            cond: c,
            then_blk: then,
            else_blk: Some(else_blk),
        },
    If <c:Expr> Then <then:Block> =>
        Stmt::If {
            cond: c,
            then_blk: then,
            else_blk: None,
        },
    Return <e:Expr> Semi => Stmt::Return(Some(e)),
    Return Semi => Stmt::Return(None),
}

VarDecls: Vec<VarDecl> = {
    => vec![],
    <v:VarDecl> <mut rest:VarDecls> => { rest.insert(0, v); rest }
};

VarDecl: VarDecl =
    <id:Ident> Eq <e:Expr> Semi => VarDecl { ident: id, expr: e };

Ident: String = <tok:IDENT> => {
    match tok { Token::Ident(s) => s, _ => unreachable!() }
};
Num: i64     = <tok:NUM>   => {
    match tok { Token::Num(n) => n, _ => unreachable!() }
};

StringLiteral: String = {
    <s:StrLiteral> => {
        match s {
            Token::StrLiteral(str) => str,
            _ => unreachable!(),
        }
    }
};

Expr: Expr = Equality;

Equality: Expr = {
    <l:Equality> EqEq <r:AddAndMinus> => Expr::Eq(Box::new(l), Box::new(r)),
    <l:Equality> Neq <r:AddAndMinus> => Expr::Neq(Box::new(l), Box::new(r)),
    <a:AddAndMinus>                   => a,
}

AddAndMinus: Expr = {
    <l:AddAndMinus> Plus <r:MulAndDiv> => Expr::Add(Box::new(l), Box::new(r)),
    <l:AddAndMinus> Minus <r:MulAndDiv> => Expr::Minus(Box::new(l), Box::new(r)),
    <m:MulAndDiv>              => m,
};

MulAndDiv: Expr = {
    <l:MulAndDiv> Star <r:Factor> => Expr::Mul(Box::new(l), Box::new(r)),
    <l:MulAndDiv> Div <r:Factor> => Expr::Div(Box::new(l), Box::new(r)),
    <p:Postfix> => p,
};

Postfix: Expr = {
    <e:Postfix> PlusPlus => Expr::Increment(Box::new(e)),
    <e:Postfix> MinusMinus => Expr::Decrement(Box::new(e)),
    <f:Factor> => f,
}

Factor: Expr = {
    <n:Num> => Expr::Number(n),
    <s:StringLiteral> => Expr::Str(s),
    <id:Ident> LParen <args:ArgList> RParen => Expr::Call(id, args, None),
    <id:Ident> => Expr::Var(id),
    LParen <e:Expr> RParen => e,
};