# sprs

`sprs` は、シンプルな構文を持つプログラミング言語です。このドキュメントでは、sprs 言語の仕様について説明します。

## sprs 言語仕様

### 言語の概要

sprs は、以下の特徴を持つシンプルなプログラミング言語です：

- 関数定義をサポート
- 変数宣言と代入
- 条件分岐（if-then-else）
- 整数演算（加算、乗算）
- 比較演算（等価比較）
- 関数呼び出し
- 組み込み関数（`print` など）

### 字句仕様（トークン）

sprs 言語では、以下のトークンが定義されています：

#### キーワード
- `fn` - 関数定義
- `if` - 条件分岐
- `then` - if 文の then 節
- `else` - if 文の else 節
- `return` - 関数からの戻り値

#### 演算子・記号
- `{` `}` - ブロックの開始・終了
- `(` `)` - グループ化、関数呼び出し
- `+` - 加算演算子
- `*` - 乗算演算子
- `=` - 代入演算子
- `==` - 等価比較演算子
- `;` - 文の終端
- `,` - パラメータ・引数の区切り

#### リテラル
- **数値リテラル**: 整数（例: `0`, `5`, `123`）
  - 正規表現: `[0-9]+`
- **識別子**: 変数名、関数名（例: `x`, `test`, `main`）
  - 正規表現: `[A-Za-z_][A-Za-z0-9_]*`

#### 空白文字
- スペース、タブ、改行、フォームフィードは無視されます

### 構文仕様

#### プログラム構成

sprs プログラムは、1 つ以上の **アイテム（Item）** から構成されます：

```
プログラム ::= アイテム+
アイテム ::= 関数定義 | 変数宣言
```

プログラムの実行は、`main` 関数から開始されます。`main` 関数が見つからない場合、最初に定義された関数が実行されます。

#### 関数定義

関数は `fn` キーワードを使って定義します：

```
関数定義 ::= "fn" 識別子 "(" パラメータリスト ")" ブロック
パラメータリスト ::= ε | パラメータ ("," パラメータ)*
パラメータ ::= 識別子
```

例：
```sprs
fn add(a, b) {
    result = a + b;
    return result;
}

fn greet() {
    print(42);
}
```

#### ブロック

ブロックは、`{` と `}` で囲まれた文の列です：

```
ブロック ::= "{" 文* "}"
```

#### 文（Statement）

sprs では、以下の種類の文が使用できます：

```
文 ::= 変数宣言
     | 式文
     | if文
     | return文
```

##### 変数宣言

変数は識別子、`=`、式、そしてセミコロンで宣言します：

```
変数宣言 ::= 識別子 "=" 式 ";"
```

例：
```sprs
x = 10;
y = x + 5;
```

##### 式文

式の後にセミコロンを付けることで、式文になります：

```
式文 ::= 式 ";"
```

##### if 文

条件分岐を行います。`else` 節は省略可能です：

```
if文 ::= "if" 式 "then" ブロック
       | "if" 式 "then" ブロック "else" ブロック
```

例：
```sprs
if a == 5 then {
    print(a);
}

if x == 0 then {
    print(0);
} else {
    print(1);
}
```

条件式は以下のように評価されます：
- `Bool` 型の値はそのまま真偽値として扱われる
- `Int` 型の値は、`0` が偽、それ以外が真として扱われる

##### return 文

関数から値を返します。値は省略可能です：

```
return文 ::= "return" ";"
          | "return" 式 ";"
```

例：
```sprs
return;
return 42;
return a + b;
```

#### 式（Expression）

sprs では、以下の式が使用できます：

```
式 ::= 等価式

等価式 ::= 加算式
        | 等価式 "==" 加算式

加算式 ::= 乗算式
        | 加算式 "+" 乗算式

乗算式 ::= 一次式
        | 乗算式 "*" 一次式

一次式 ::= 数値リテラル
        | 識別子
        | 関数呼び出し
        | "(" 式 ")"
```

##### 演算子の優先順位

演算子は以下の優先順位で評価されます（上から低い順）：

1. `==` (等価比較)
2. `+` (加算)
3. `*` (乗算)
4. 一次式（数値、変数、関数呼び出し、括弧）

##### 関数呼び出し

関数呼び出しは、識別子の後に括弧で囲まれた引数リストを記述します：

```
関数呼び出し ::= 識別子 "(" 引数リスト ")"
引数リスト ::= ε | 式 ("," 式)*
```

例：
```sprs
print(42);
result = add(5, 10);
test();
```

### 評価モデル / 実行時仕様

#### 値の型

sprs の実行時には、以下の型の値が存在します：

- `Int(i64)` - 64ビット整数
- `Bool(bool)` - 真偽値
- `Str(String)` - 文字列（将来の拡張用）
- `Unit` - 値を持たない型（`()` で表される）
- `Return(Value)` - return 文で返される値を内包する特殊な型

#### 演算の評価規則

##### 加算 (`+`)
- `Int + Int` → `Int`（整数の加算）
- その他の組み合わせ → `Unit`

##### 乗算 (`*`)
- `Int * Int` → `Int`（整数の乗算）
- その他の組み合わせ → `Unit`

##### 等価比較 (`==`)
- 両辺の値を評価し、`PartialEq` によって比較
- 結果は `Bool` 型

#### 変数のスコープ

- 変数は関数内のローカルスコープで管理されます
- 関数のパラメータも関数内のローカル変数として扱われます
- 未定義の変数にアクセスするとエラーになります

#### 関数の実行

1. 関数が呼び出されると、新しいスコープが作成されます
2. 引数が評価され、パラメータに対応する変数にバインドされます
3. 関数本体（ブロック）が実行されます
4. `return` 文で値が返されるか、ブロックの最後まで実行されると `Unit` が返されます

### 組み込み関数

#### `print`

任意個の引数を受け取り、それぞれを評価して標準出力に表示します。

```
print(式, 式, ...)
```

- 引数：0 個以上の任意の式
- 戻り値：`Unit`

例：
```sprs
print(42);
print(x);
print(1, 2, 3);
```

### コード例

#### 例1: 基本的な関数と条件分岐

```sprs
fn test() {
    a = 5;
    b = 10;

    if a == 5 then {
        return a;
    }

    return b;
}

fn main() {
   x = test();
   print(x);
}
```

**実行結果：**
```
5
```

**説明：**
- `test` 関数内で変数 `a` と `b` を宣言
- `a == 5` が真なので、then ブロックが実行される
- `return a;` で値 `5` を返す
- `main` 関数で `test()` を呼び出し、戻り値を `x` に代入
- `print(x)` で `5` を出力

#### 例2: 演算と関数呼び出し

```sprs
fn calc() {
    x = 3;
    y = 4;
    result = x * y + 2;
    return result;
}

fn main() {
    answer = calc();
    print(answer);
}
```

**実行結果：**
```
14
```

**説明：**
- `3 * 4 + 2` が評価され、`12 + 2 = 14` となる
- 演算子の優先順位により、`*` が先に評価される

#### 例3: if-else 文

```sprs
fn check(n) {
    if n == 0 then {
        print(0);
    } else {
        print(1);
    }
}

fn main() {
    check(0);
    check(5);
}
```

**実行結果：**
```
0
1
```

## ビルドと実行

### 必要な環境

- Rust（2024 edition）
- Cargo

### ビルド

```bash
cargo build
```

### 実行

```bash
cargo run
```

現在の実装では、`src/main.rs` に記述されたサンプルコードが実行されます。

## ライセンス

（プロジェクトのライセンス情報をここに追加してください）

## 貢献

（貢献ガイドラインをここに追加してください）
